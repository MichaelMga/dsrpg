
queues and stacks : 3 exercices per subject


Binary trees
   

linked list


graphs

Depth first search :

Traverse this tree using DFS in this order 

In this order

In this order

In this order

worst case time complexity

Breadth first search 

Traverse this tree using Breadth first search 

worst time complexity

heaps

valid/ invalid heaps

insertion 

deletion

strings


 Karp rabin

longest common substring

sort 

 quicksort

 mergesort

 select sort


Glasses

==> How many glasses are there?

     (recursion => first vertical => Then horizontal (break if i + 2 >  ))



Hashing 

Polynamial construction

Linked list

Linear probing 

Quadratic probing


Shortest path

  Dijskstra

  Prims 

Minimal path

   Kruskal

A*



AVL trees


 Left pivot

 Right pivot




Trie



Dynamic programming



Table doubling (avoid doubling, deleting, doubling, deleting...)



Amortization (to calculate time complexity)




String manipulations 



Greedy algorithms 

  => Greedy algorithms are simple , intuitive programs.

  The algorithm makes the optimal choice at each step (In some cases, it allows to reach a global optimum, but in general, its a heuristic)


